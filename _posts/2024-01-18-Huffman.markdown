---
title:  "Huffman Encoding"
excerpt: "효율적인 문자열 압축"
last_modified_at: 2024-01-18
categories:
  - Algorithm
tags:
  - Algorithm
---
# Huffman Encoding
문자열을 압축하는 방법 중 하나로, 자주 등장하는 문자는 짧은 문자열로, 그렇지 않다면 긴 문자열로 압축하는 방식이다.

허프먼 코드는 이하의 규칙을 만족한다.
 * 같은 문자면 같은 문자열로, 다른 문자면 다른 문자열로 압축한다.
 * 모든 문자는 Prefix-Free하다.
 * 허프먼 코드는 완전이진트리로 나타낼 수 있어야 한다.

## Prefix-Free?
어떠한 문자에 대한 인코딩도 다른 문자의 인코딩의 접두어가 되어서는 안 된다는 것을 의미한다. 즉 특정 문자에 대한 인코딩이 $P$라면, 다른 어떠한 문자에 대해서도 $P+Q$ 형태의 인코딩이 나오지 않는다.

### 예시

 | 문자 | 빈도 | 인코딩 결과 | 
 |---|---|-----|
 |A|1위|0|
 |B|4위|100|
 |C|3위|101|
 |D|2위|11|

 이 경우 어떠한 문자를 선택해도 다른 문자의 접두어가 되지 않는다. 예를 들어서, 100101은 무조건 BC로 복호화되고, 다른 단어로 오독되지 않는다. '100'으로 시작하는 문자는 B뿐이고, 1, 10으로 인코딩되는 단어도 없기 때문이다.

## How to Encode
* 인코딩된 문자열의 길이를 최소화하는 방향으로 접근한다. 즉
 $$ \sum_{i=1}^n f_i*\text{트리에서 i번째 원소의 깊이}$$
 를 최소화하는 방향으로 계산하게 된다.
* 빈도가 가장 낮은 문자 $f_1, f_2$를 잎으로 하는 이진트리를 만든다. 이 이진트리의 루트의 가중치 빈도는 $f_1, f_2$의 빈도의 합이 된다.
* 이진트리의 왼쪽 간선은 0, 오른쪽 간선은 1의 가중치를 받는다.
* 이렇게 만들어진 트리와 기존의 문자들을 합치는 과정을 반복하면서 이진트리를 완성한다.
* 완성된 트리에서, 루트 노드에서 원하는 글자의 노드까지 가는 과정에서 만나게 되는 이진 값을 일렬로 적으면 그 값이 그 문자의 인코딩 결과가 된다.

이상의 과정을 의사코드로 나타내면 이하와 같다.
```
f[x]=the frequency of node x
H=an empty priority queue, which is minimal heap

for i=1 to n: enqueue i in H
for k=n+1 to 2n-1:
  p=dequeue(H)
  q=dequeue(H)
  f[k]=f[p]+f[q]
  enqueue k in H
```
항상 가장 빈도가 낮은 문자 2개를 빼서 합쳐야 하기 때문에, 언제나 최솟값을 return해 주는 최소 힙을 이용한다.


# 출처
<https://compression.ru/download/articles/huff/huffman_1952_minimum-redundancy-codes.pdf>